#!/bin/bash

# --- 1. Color Palette ---
reset='\033[0m'
bold='\033[1m'
dim='\033[2m'
red='\033[38;5;196m'
green='\033[38;5;71m'
yellow='\033[38;5;214m'
blue='\033[38;5;75m'
magenta='\033[38;5;176m'
cyan='\033[38;5;79m'
white='\033[38;5;255m'
gray='\033[38;5;244m'

bg_crit='\033[48;5;160;38;5;255;1m' # Red background
bg_core='\033[48;5;237;38;5;214;1m' # Dark gray background

# --- 2. Critical Package Configuration ---
CRITICAL_PKGS=(
    # --- Kernels & Microcode ---
    "linux" "linux-headers"
    "linux-lts" "linux-lts-headers"
    "linux-zen" "linux-zen-headers"
    "linux-hardened" "linux-hardened-headers"
    "linux-firmware" "amd-ucode"

    # --- NVIDIA Drivers ---
    "nvidia" "nvidia-lts" "nvidia-dkms"
    "nvidia-open" "nvidia-open-lts" "nvidia-open-dkms"
    "nvidia-utils" "nvidia-settings" "lib32-nvidia-utils"
    "opencl-nvidia" "lib32-opencl-nvidia"

    # --- Systemd & Init ---
    "systemd" "systemd-libs" "systemd-sysvcompat"
    "systemd-resolvconf"
    "lib32-systemd"

    # --- Core System & Base ---
    "base" "base-devel" "filesystem"
    "glibc" "lib32-glibc" "dbus"
    "gcc-libs" "lib32-gcc-libs" "util-linux"
    "libutil-linux" "openssl" "coreutils" "icu"
    "bash" "zsh" "sudo" "polkit" "shadow"
    "cryptsetup" "device-mapper" "zstd"

    # --- Package Management ---
    "pacman" "pacman-contrib" "pacman-mirrorlist"
    "archlinux-keyring" "endeavouros-keyring"
    "yay" "paru"

    # --- EndeavourOS Specific ---
    "eos-update" "eos-hooks" "endeavouros-theming"
    "welcome" "eos-apps-info" "eos-rankmirrors"
    "eos-sddm-theme"

    # --- Bootloaders ---
    "grub" "efibootmgr" "os-prober" "dracut"

    # --- Graphics Stack ---
    "mesa" "lib32-mesa" "vulkan-icd-loader" "lib32-vulkan-icd-loader"
    "xorg-server" "xorg-xwayland" "wayland" "wayland-protocols"

    # AMD Drivers
    "xf86-video-amdgpu"
    "vulkan-radeon" "lib32-vulkan-radeon"

    # Hardware Video Acceleration
    "libva-mesa-driver" "lib32-libva-mesa-driver" "mesa-vdpau"

    # --- KDE ---
    "plasma-desktop" "plasma-workspace" "kwin"
    "systemsettings" "sddm" "plasma-wayland-session"
    "kde-cli-tools" "powerdevil"

    # Frameworks & Libraries
    "qt6-base" "qt5-base" "kwayland" "egl-wayland"

    # Hybrid Graphics Switcher
    "switcheroo-control" "envycontrol" "optimus-manager"

    # Core Apps
    "dolphin" "konsole"

    # --- Audio & Networking ---
    "pipewire" "pipewire-audio" "wireplumber" "pipewire-pulse" "lib32-pipewire"
    "networkmanager" "iwd" "bluez" "bluez-utils"
)

declare -A CRIT_MAP
for pkg in "${CRITICAL_PKGS[@]}"; do CRIT_MAP["$pkg"]=1; done

# --- 3. Temporary Files ---
OUTPUT_FILE=$(mktemp)
SYNC_LOG=$(mktemp)

if ! CHECK_DB=$(mktemp -d /tmp/checkupdates-db.XXXXXX); then
    echo -e "${red}Error: Could not create temp db directory.${reset}"
    exit 1
fi

cleanup() {
    if [[ -n "$CHECK_DB" && -d "$CHECK_DB" && "$CHECK_DB" == /tmp/* && "$CHECK_DB" != "/tmp/" ]]; then
        sudo rm -rf "$CHECK_DB"
    fi

    local files_to_remove=()
    [[ -f "$OUTPUT_FILE" ]] && files_to_remove+=("$OUTPUT_FILE")
    [[ -f "$SYNC_LOG" ]] && files_to_remove+=("$SYNC_LOG")

    if [[ ${#files_to_remove[@]} -gt 0 ]]; then
        rm -f "${files_to_remove[@]}"
    fi
}

trap cleanup EXIT INT TERM

# --- 4. Helper Functions ---
log_step() {
    echo -e "${dim}[$(date +%T)] $1${reset}"
}

get_update_type() {
    local old=$1 new=$2

    local v_old=${old#*:}
    local v_new=${new#*:}

    if [[ "$old" == *":"* || "$new" == *":"* ]]; then
        local e_old=${old%%:*}
        local e_new=${new%%:*}
        [[ "$e_old" != "$e_new" ]] && { echo "EPOCH"; return; }
    fi

    local nums_old=($(echo "$v_old" | sed 's/[^0-9]/ /g'))
    local nums_new=($(echo "$v_new" | sed 's/[^0-9]/ /g'))

    local len=${#nums_new[@]}
    for (( i=0; i<len; i++ )); do
        local n_old=${nums_old[$i]}
        local n_new=${nums_new[$i]}

        [[ -z "$n_old" ]] && { echo "MINOR"; return; }

        if (( 10#$n_old != 10#$n_new )); then

            if (( 10#$n_new >= 2020 && 10#$n_new <= 2100 )); then
                echo "CALVER"
                return
            fi

            if (( i == 0 )); then
                echo "MAJOR"
            elif (( i == 1 )); then
                echo "MINOR"
            else
                echo "Patch"
            fi
            return
        fi
    done

    echo "Patch"
}

get_type_color() {
    case $1 in
        "MAJOR") echo "$red$bold" ;;
        "CALVER") echo "$blue$bold" ;;
        "MINOR") echo "$cyan" ;;
        "EPOCH") echo "$magenta" ;;
        *) echo "$gray" ;;
    esac
}

check_arch_news() {
    log_step "Starting Arch News check (Python XML)..."
    echo -ne "${gray}  Checking Arch News... ${reset}"

    if news_ts=$(curl -sf --connect-timeout 2 --max-time 3 https://archlinux.org/feeds/news/ | python3 -c "
import sys
import xml.etree.ElementTree as ET
import email.utils

try:
    # Reading stdin
    root = ET.fromstring(sys.stdin.read())

    # Looking for the first <item> element inside <channel>
    item = root.find('./channel/item')

    if item is not None:
        pubDate = item.find('pubDate').text
        # Parsing an RFC 822 date into a time tuple
        parsed = email.utils.parsedate_tz(pubDate)
        # Convert to timestamp (seconds)
        timestamp = email.utils.mktime_tz(parsed)
        print(int(timestamp))
    else:
        sys.exit(1)
except Exception:
    sys.exit(1)
"); then
        now_time=$(date +%s)
        diff_hours=$(( (now_time - news_ts) / 3600 ))

        if (( diff_hours < 336 )); then # 14 days
            echo -e "\r\033[2K${red}${bold}  ⚠ WARNING: Fresh Arch News detected ($diff_hours h ago)!${reset}"
            echo -e "  ${red}  Check https://archlinux.org/ before updating.${reset}\n"
        else
            echo -e "\r\033[2K${green}  ✔ No fresh Arch News (last: ${diff_hours}h ago).${reset}\n"
        fi
    else
        echo -e "\r\033[2K${dim}  ? Could not check Arch News (Connection or XML error).${reset}\n"
    fi
}

# --- 5. Mirror Refresh Function ---
refresh_mirrors() {
    echo -e "\n${yellow}${bold}⚠  Mirror instability detected (timeouts or errors).${reset}"
    echo -ne "  ${white}Refresh mirrors (Germany/Netherlands, HTTPS, Rate)? [Y/n]: ${reset}"
    read -r ans
    if [[ "$ans" =~ ^[Yy]$ || -z "$ans" ]]; then
        echo -e "  ${blue}Running reflector (WARNINGS ARE EXPECTED)${reset}"
        if command -v reflector &>/dev/null; then
            if sudo reflector --country Germany,Netherlands --protocol https --sort rate --save /etc/pacman.d/mirrorlist --download-timeout 5; then
                echo -e "  ${green}✔ Mirrors updated successfully.${reset}\n"
                return 0
            else
                echo -e "  ${red}✘ Reflector failed.${reset}\n"
                return 1
            fi
        else
            echo -e "  ${red}✘ Error: 'reflector' is not installed.${reset}\n"
            return 1
        fi
    fi
    return 1
}

# --- 6. Main Logic ---
log_step "Requesting Sudo access..."
if ! sudo -v; then
    echo -e "${red}Error: Sudo authentication failed.${reset}"
    exit 1
fi

echo -e "\n${blue}${bold}  󰚰  Checking for updates...${reset}"

if [[ -f /var/lib/pacman/db.lck ]]; then
    echo -e "${red}Error: Pacman database is locked (/var/lib/pacman/db.lck).${reset}"
    echo -e "${yellow}Another package manager process is running.${reset}"
    exit 1
fi

check_arch_news

log_step "Symlinking local DB..."
ln -s /var/lib/pacman/local "$CHECK_DB/local" > /dev/null 2>&1

sudo chown -R root:root "$CHECK_DB"
sudo chmod 755 "$CHECK_DB"

MAX_RETRIES=1
attempt=0

while (( attempt <= MAX_RETRIES )); do
    log_step "Syncing temporary database (pacman -Sy)..."

    set -o pipefail
    if sudo pacman -Sy --dbpath "$CHECK_DB" --logfile /dev/null 2>&1 | tee "$SYNC_LOG"; then
        PACMAN_EXIT=0
    else
        PACMAN_EXIT=$?
    fi
    set +o pipefail

    if grep -iqE "error|failed|timed out|could not resolve" "$SYNC_LOG"; then
        IS_DIRTY=1
    else
        IS_DIRTY=0
    fi

    if [[ $PACMAN_EXIT -eq 0 && $IS_DIRTY -eq 0 ]]; then
        break
    else
        if (( attempt < MAX_RETRIES )); then
            if refresh_mirrors; then
                ((attempt++))
                log_step "Retrying sync..."
                continue
            else
                if [[ $PACMAN_EXIT -eq 0 ]]; then
                     echo -e "${yellow}Proceeding despite mirror warnings...${reset}"
                     break
                fi
            fi
        fi

        if [[ $PACMAN_EXIT -ne 0 ]]; then
            echo -e "${red}Error: Could not sync databases.${reset}"
            exit 1
        else
            break
        fi
    fi
done

log_step "Calculating update list (pacman -Qu)..."
updates=$(LC_ALL=C pacman -Qu --dbpath "$CHECK_DB" --color never)

if [[ -z "$updates" ]]; then
    echo -e "${green}  ✔ System is fully up to date.${reset}\n"
    exit 0
fi

pkg_count=$(echo "$updates" | wc -l)
log_step "Found $pkg_count updates. Starting detailed analysis..."
echo -e "${blue}${bold}  󰑮  Analyzing updates: ${white}$pkg_count packages${reset}"

all_pkgs=$(echo "$updates" | awk '{print $1}')

log_step "Fetching remote metadata (pacman -Si)..."
declare -A NEW_DATA
while IFS='' read -r line; do
    name=${line%%~|~*}
    rest=${line#*~|~}
    NEW_DATA["$name"]="$rest"
done < <(LC_ALL=C pacman -Si --dbpath "$CHECK_DB" --color never $all_pkgs 2>/dev/null | awk -F': ' '
    /^Name/ {n=$2}
    /^Repository/ {r=$2}
    /^Build Date/ {b=$2}
    /^Download Size/ {s=$2}
    /^Description/ {
        d=$2
        # Description cleanup: replacing |, tab, and ~ with spaces to preserve structure
        gsub(/[|\t~]/, " ", d)
    }
    /^$/ {
        if (n) {
            print n "~|~" r "|" b "|" s "|" d
            n=""
        }
    }
    END {
        if (n) print n "~|~" r "|" b "|" s "|" d
    }
')

log_step "Fetching local metadata (pacman -Qi)..."
declare -A OLD_DATA
while IFS='|' read -r name bdate reason; do
    [[ -z "${OLD_DATA[$name]}" ]] && OLD_DATA["$name"]="$bdate|$reason"
done < <(LC_ALL=C pacman -Qi $all_pkgs 2>/dev/null | awk -F': ' '
    /^Name/ {n=$2}
    /^Build Date/ {b=$2}
    /^Install Reason/ {r=$2}
    /^$/ {if (n) print n "|" b "|" r; n=""}
')

total_download_size=$(LC_ALL=C pacman -Si --dbpath "$CHECK_DB" $all_pkgs 2>/dev/null | awk '
    /^Download Size/ {
        val=$4
        unit=$5
        if (unit == "KiB") val /= 1024
        else if (unit == "GiB") val *= 1024
        sum += val
    }
    END {
        if (sum > 1024) printf "%.2f GiB", sum/1024
        else printf "%.2f MiB", sum
    }
')

log_step "Processing data and calculating diffs..."

now=$(date +%s)
current_idx=0

max_name=7
max_old=3
max_new=3
max_repo=4
max_size=4

while read -r line; do
    ((current_idx++))
    percent=$(( current_idx * 100 / pkg_count ))

    if (( percent % 5 == 0 || current_idx == pkg_count )); then
        filled=$(( percent / 5 ))
        empty=$(( 20 - filled ))
        printf "\r\033[2K  ${gray}Analysis: ${blue}["
        printf "%${filled}s" | tr ' ' '='
        printf ">"
        printf "%${empty}s" | tr ' ' '-'
        printf "] ${percent}%%${reset}"
    fi

    pkgname=$(echo "$line" | awk '{print $1}')
    old_ver=$(echo "$line" | awk '{print $2}')
    new_ver=$(echo "$line" | awk '{print $4}')

    IFS='|' read -r repo date_new size desc <<< "${NEW_DATA[$pkgname]}"
    IFS='|' read -r date_old reason <<< "${OLD_DATA[$pkgname]}"

    is_explicit=0
    [[ "$reason" == *"Explicitly"* ]] && is_explicit=1

    (( ${#pkgname} > max_name )) && max_name=${#pkgname}
    (( ${#old_ver} > max_old )) && max_old=${#old_ver}
    (( ${#new_ver} > max_new )) && max_new=${#new_ver}
    (( ${#repo} > max_repo )) && max_repo=${#repo}
    (( ${#size} > max_size )) && max_size=${#size}

    diff_hours=9999
    if [[ -n "$date_new" ]]; then
        build_time=$(date -d "$date_new" +%s 2>/dev/null || echo 0)
        diff_hours=$(( (now - build_time) / 3600 ))
    fi

    is_crit=0
    [[ ${CRIT_MAP["$pkgname"]} ]] && is_crit=1

    upd_type=$(get_update_type "$old_ver" "$new_ver")

    sort_prio=$(( 1 - is_crit ))
    sort_key=$(printf "%d.%05d" "$sort_prio" "$diff_hours")

    printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$sort_key" "$diff_hours" "$is_crit" "$upd_type" "$pkgname" "$old_ver" "$new_ver" \
        "$repo" "$size" "$is_explicit" "$date_old" "$date_new" "$desc" >> "$OUTPUT_FILE"

done <<< "$updates"

echo -e "\n"

# --- 7. Table Output ---
w_age=6
w_stat=8
w_repo=$(( max_repo ))
w_type=6
w_name=$(( max_name ))
w_old=$(( max_old ))
w_new=$(( max_new ))
w_size=$(( max_size ))
w_date=12

term_cols=$(tput cols)
used_width=$(( w_age + 1 + w_stat + 1 + w_repo + 1 + w_type + 1 + w_name + 1 + w_old + 3 + w_new + 1 + w_size + 1 + w_date + 1 ))
w_desc=$(( term_cols - used_width - 1 ))

if (( w_desc < 5 )); then
    w_desc=0
fi

sep_line=$(printf "%${term_cols}s" | tr ' ' '-')

printf "${dim}%s${reset}\n" "$sep_line"

fmt_center() {
    local str="$1"
    local width="$2"
    local len=${#str}
    if (( len >= width )); then
        printf "%s" "$str"
    else
        local l_pad=$(( (width - len) / 2 ))
        local r_pad=$(( width - len - l_pad ))
        printf "%*s%s%*s" $l_pad "" "$str" $r_pad ""
    fi
}

h_age=$(fmt_center "AGE" "$w_age")
h_stat=$(fmt_center "STATUS" "$w_stat")
h_repo=$(fmt_center "REPO" "$w_repo")
h_type=$(fmt_center "TYPE" "$w_type")
h_name=$(fmt_center "PACKAGE" "$w_name")
h_old=$(fmt_center "OLD" "$w_old")
h_new=$(fmt_center "NEW" "$w_new")
h_size=$(fmt_center "SIZE" "$w_size")
h_date=$(fmt_center "NEW DATE" "$w_date")

h_desc="DESCRIPTION"
(( w_desc == 0 )) && h_desc=""

printf "${bold}${gray}%s %s %s %s %s %s   %s %s %s %s${reset}\n" \
    "$h_age" "$h_stat" "$h_repo" "$h_type" "$h_name" "$h_old" "$h_new" "$h_size" "$h_date" "$h_desc"

printf "${dim}%s${reset}\n" "$sep_line"

sort -n "$OUTPUT_FILE" | while IFS=$'\t' read -r key diff_hours is_crit upd_type pkgname old_ver new_ver repo size is_explicit date_old date_new desc; do

    if (( diff_hours == 9999 )); then age_disp="[?]"; age_col=$dim
    else
        age_disp="[${diff_hours}h]"
        if (( diff_hours < 12 )); then age_col="${red}${bold}"
        elif (( diff_hours < 48 )); then age_col="${yellow}"
        else age_col="${green}"; fi
    fi
    printf -v f_age "%-${w_age}s" "$age_disp"
    out_age="${age_col}${f_age}${reset}"

    if (( is_crit == 1 )); then
        if (( diff_hours < 24 )); then out_stat="${bg_crit} ! CRIT ${reset}"
        else out_stat="${bg_core}  CORE  ${reset}"; fi
    else out_stat="$(printf "%-${w_stat}s" " ")"; fi

    printf -v f_repo "%-${w_repo}s" "$repo"
    out_repo="${dim}${f_repo}${reset}"

    type_col=$(get_type_color "$upd_type")
    printf -v f_type "%-${w_type}s" "$upd_type"
    out_type="${type_col}${f_type}${reset}"

    if (( is_explicit == 1 )); then
        name_col="${white}${bold}"
    else
        name_col="${gray}"
    fi
    printf -v f_name "%-${w_name}s" "$pkgname"
    out_name="${name_col}${f_name}${reset}"

    if [[ -n "$date_new" ]]; then
        f_date_raw=$(LC_TIME=C date -d "$date_new" "+%d %b %H:%M" 2>/dev/null)
    else
        f_date_raw=""
    fi
    printf -v f_date_padded "%-${w_date}s" "$f_date_raw"
    out_date_new="${dim}${f_date_padded}${reset}"

    printf -v f_size "%-${w_size}s" "$size"
    out_size="${white}${f_size}${reset}"

    if (( w_desc > 0 )); then
        if (( ${#desc} > w_desc )); then
            out_desc="${dim}${desc:0:$((w_desc-1))}…${reset}"
        else
            out_desc="${dim}${desc}${reset}"
        fi
    else
        out_desc=""
    fi

    printf "%b %b %b %b %b ${gray}%${w_old}s${reset} ${blue}→${reset} ${white}%-${w_new}s${reset} %b %b %b\n" \
        "$out_age" "$out_stat" "$out_repo" "$out_type" "$out_name" \
        "$old_ver" "$new_ver" "$out_size" "$out_date_new" "$out_desc"

done

printf "${dim}%s${reset}\n" "$sep_line"
echo -e "  ${gray}Total Download Size: ${white}${bold}${total_download_size}${reset}"

# --- 8. Update Request ---
if awk -F'\t' '$5 ~ /^(linux.*|nvidia.*|systemd.*|.*-ucode|cryptsetup|glibc|linux-firmware|mesa|wayland|xorg-server|dbus.*|qt[56]-base|plasma-.*|kwin|egl-wayland)$/' "$OUTPUT_FILE" | grep -q .; then
    echo -e "  ${red}${bold}⚠  Kernel/Core/DE update detected. Reboot will be required!${reset}"
fi

if command -v eos-update &> /dev/null; then
    CORE_CMD="eos-update"
else
    CORE_CMD="sudo pacman -Syu"
fi

EXTRA_CMD=""
if command -v topgrade &> /dev/null; then
    EXTRA_CMD="topgrade"
fi

if [[ -n "$EXTRA_CMD" ]]; then
    PROMPT_CMD="${CORE_CMD} && ${EXTRA_CMD}"
else
    PROMPT_CMD="${CORE_CMD}"
fi

sudo -v

echo -ne "\n  ${bold}${white}Apply updates?${reset} ${dim}(${PROMPT_CMD})${reset} [Y/n]: "

read -r answer

if [[ "$answer" =~ ^[Yy]$ || -z "$answer" ]]; then
    echo -e "\n"

    $CORE_CMD
    core_exit=$?

    pending_updates=$(LC_ALL=C pacman -Qu 2>/dev/null)

    run_extra=false

    if [[ -z "$pending_updates" ]]; then
        if [[ $core_exit -eq 0 ]]; then
            echo -e "\n${green}✔ Core updates applied successfully.${reset}"
            run_extra=true
        else
            echo -e "\n${green}✔ No core updates pending.${reset}"
            run_extra=true
        fi

    else
        echo -e "\n${yellow}⚠  Core updates were NOT fully applied (Cancelled or Failed).${reset}"

        if [[ -n "$EXTRA_CMD" ]]; then
            echo -ne "  ${white}Run ${EXTRA_CMD} anyway? (Flatpaks/AUR etc) [y/N]: ${reset}"
            read -r force_extra
            if [[ "$force_extra" =~ ^[Yy]$ ]]; then
                run_extra=true
            else
                echo -e "  ${dim}Skipping extra updates.${reset}\n"
            fi
        fi
    fi

    if [[ "$run_extra" == true && -n "$EXTRA_CMD" ]]; then
        echo -e "\n${blue}${bold}  󰚰  Running Topgrade...${reset}\n"
        $EXTRA_CMD
    elif [[ -n "$pending_updates" ]]; then
        echo -e "\n${red}  ✘ System partially updated or update cancelled.${reset}\n"
    fi

else
    echo -e "  ${yellow}Operation cancelled.${reset}\n"
fi
