#!/bin/bash

# --- 1. Color Palette ---
reset='\033[0m'
bold='\033[1m'
dim='\033[2m'
red='\033[38;5;196m'
green='\033[38;5;71m'
yellow='\033[38;5;214m'
blue='\033[38;5;75m'
magenta='\033[38;5;176m'
cyan='\033[38;5;79m'
white='\033[38;5;255m'
gray='\033[38;5;244m'

# Backgrounds for statuses
bg_crit='\033[48;5;160;38;5;255;1m' # Red background
bg_core='\033[48;5;237;38;5;214;1m' # Dark gray background

# --- 2. Critical Package Configuration ---
CRITICAL_PKGS=(
    # --- Kernels & Microcode (AMD CPU) ---
    "linux" "linux-headers"
    "linux-lts" "linux-lts-headers"
    "linux-zen" "linux-zen-headers"
    "linux-hardened" "linux-hardened-headers"
    "linux-firmware" "amd-ucode"

    # --- NVIDIA Drivers (Discrete GPU) ---
    "nvidia" "nvidia-lts" "nvidia-dkms"
    "nvidia-open" "nvidia-open-lts" "nvidia-open-dkms"
    "nvidia-utils" "nvidia-settings" "lib32-nvidia-utils"
    "opencl-nvidia" "lib32-opencl-nvidia"

    # --- Systemd & Init ---
    "systemd" "systemd-libs" "systemd-sysvcompat"
    "systemd-resolvconf"
    "lib32-systemd"

    # --- Core System & Base ---
    "base" "base-devel" "filesystem"
    "glibc" "lib32-glibc" "dbus"
    "gcc-libs" "lib32-gcc-libs" "util-linux"
    "libutil-linux" "openssl" "coreutils" "icu"
    "bash" "zsh" "sudo" "polkit" "shadow"
    "cryptsetup" "device-mapper" "zstd"

    # --- Package Management ---
    "pacman" "pacman-contrib" "pacman-mirrorlist"
    "archlinux-keyring" "endeavouros-keyring"
    "yay" "paru"

    # --- EndeavourOS Specific ---
    "eos-update" "eos-hooks" "endeavouros-theming"
    "welcome" "eos-apps-info" "eos-rankmirrors"
    "eos-sddm-theme"

    # --- Bootloaders ---
    "grub" "efibootmgr" "os-prober" "dracut"

    # --- Graphics Stack (AMD iGPU + Core) ---
    "mesa" "lib32-mesa" "vulkan-icd-loader" "lib32-vulkan-icd-loader"
    "xorg-server" "xorg-xwayland" "wayland" "wayland-protocols"

    # AMD Drivers (iGPU)
    "xf86-video-amdgpu"
    "vulkan-radeon" "lib32-vulkan-radeon"

    # Hardware Video Acceleration (AMD)
    "libva-mesa-driver" "lib32-libva-mesa-driver" "mesa-vdpau"

    # --- KDE Plasma (Desktop Environment) ---
    "plasma-desktop" "plasma-workspace" "kwin"
    "systemsettings" "sddm" "plasma-wayland-session"
    "kde-cli-tools" "powerdevil"

    # Frameworks & Libraries (Qt/Wayland/Nvidia compat)
    "qt6-base" "qt5-base" "kwayland" "egl-wayland"

    # Hybrid Graphics Switcher
    "switcheroo-control" "envycontrol" "optimus-manager"

    # Core Apps
    "dolphin" "konsole"

    # --- Audio & Networking ---
    "pipewire" "pipewire-audio" "wireplumber" "pipewire-pulse" "lib32-pipewire"
    "networkmanager" "iwd" "bluez" "bluez-utils"
)

declare -A CRIT_MAP
for pkg in "${CRITICAL_PKGS[@]}"; do CRIT_MAP["$pkg"]=1; done

# --- 3. Temporary Files ---
OUTPUT_FILE=$(mktemp)
trap 'rm -f "$OUTPUT_FILE"' EXIT

# --- 4. Helper Functions ---
get_update_type() {
    local old=$1 new=$2

    # 1. Remove Epoch
    local v_old=${old#*:}
    local v_new=${new#*:}

    # Check Epoch change
    if [[ "$old" == *":"* || "$new" == *":"* ]]; then
        local e_old=${old%%:*}
        local e_new=${new%%:*}
        [[ "$e_old" != "$e_new" ]] && { echo "EPOCH"; return; }
    fi

    # 2. Normalize and convert to integer arrays
    local nums_old=($(echo "$v_old" | sed 's/[^0-9]/ /g'))
    local nums_new=($(echo "$v_new" | sed 's/[^0-9]/ /g'))

    # 3. Iterative comparison
    local len=${#nums_new[@]}
    for (( i=0; i<len; i++ )); do
        local n_old=${nums_old[$i]}
        local n_new=${nums_new[$i]}

        # If old version had fewer segments, treat as minor/patch
        [[ -z "$n_old" ]] && { echo "MINOR"; return; }

        if (( 10#$n_old != 10#$n_new )); then

            if (( 10#$n_new >= 2020 && 10#$n_new <= 2100 )); then
                echo "CALVER"
                return
            fi

            if (( i == 0 )); then
                echo "MAJOR"
            elif (( i == 1 )); then
                echo "MINOR"
            else
                echo "Patch"
            fi
            return
        fi
    done

    echo "Patch"
}

get_type_color() {
    case $1 in
        "MAJOR") echo "$red$bold" ;;
        "CALVER") echo "$blue$bold" ;;
        "MINOR") echo "$cyan" ;;
        "EPOCH") echo "$magenta" ;;
        *) echo "$gray" ;;
    esac
}

# --- 5. Main Logic ---
echo -e "\n${blue}${bold}  󰚰  Checking for updates...${reset}"

# 1. Create a temporary directory for the sync database
CHECK_DB=$(mktemp -d /tmp/checkupdates-db.XXXXXX)

# Ensure cleanup on exit (using sudo because the folder will be owned by root)
trap 'sudo rm -rf "$CHECK_DB"; rm -f "$OUTPUT_FILE"' EXIT

# 2. Symlink the local database so pacman knows which packages are currently installed
ln -s /var/lib/pacman/local "$CHECK_DB/local" > /dev/null 2>&1

# 3. Fix Permissions
sudo chown -R root:root "$CHECK_DB"
sudo chmod 755 "$CHECK_DB"

# 4. Synchronize the TEMPORARY database
if ! sudo pacman -Sy --dbpath "$CHECK_DB" --logfile /dev/null > /dev/null 2>&1; then
    echo -e "${red}Error: Could not sync databases.${reset}"
    exit 1
fi

# 5. Get the list of updates
updates=$(LC_ALL=C pacman -Qu --dbpath "$CHECK_DB" --color never)

if [[ -z "$updates" ]]; then
    echo -e "${green}  ✔ System is fully up to date.${reset}\n"
    exit 0
fi

pkg_count=$(echo "$updates" | wc -l)
echo -e "${blue}${bold}  󰑮  Analyzing updates: ${white}$pkg_count packages${reset}"

# --- Optimization: Batch fetch build dates ---
all_pkgs=$(echo "$updates" | awk '{print $1}')
declare -A BUILD_DATES
while IFS='|' read -r name date; do
    [[ -z "${BUILD_DATES[$name]}" ]] && BUILD_DATES["$name"]="$date"
done < <(LC_ALL=C pacman -Si --dbpath "$CHECK_DB" --color never $all_pkgs 2>/dev/null | awk -F': ' '/^Name/ {n=$2} /^Build Date/ {print n "|" $2}')

now=$(date +%s)
current_idx=0

# Track Max Lengths for Alignment
max_name=7  # "PACKAGE"
max_old=3   # "OLD"
max_new=3   # "NEW"

# Process Updates
while read -r line; do
    ((current_idx++))
    percent=$(( current_idx * 100 / pkg_count ))

    # Simple progress bar
    filled=$(( percent / 5 ))
    empty=$(( 20 - filled ))
    printf "\r\033[2K  ${gray}Analysis: ${blue}["
    printf "%${filled}s" | tr ' ' '='
    printf ">"
    printf "%${empty}s" | tr ' ' '-'
    printf "] ${percent}%%${reset}"

    pkgname=$(echo "$line" | awk '{print $1}')
    old_ver=$(echo "$line" | awk '{print $2}')
    new_ver=$(echo "$line" | awk '{print $4}')

    # Update lengths
    (( ${#pkgname} > max_name )) && max_name=${#pkgname}
    (( ${#old_ver} > max_old )) && max_old=${#old_ver}
    (( ${#new_ver} > max_new )) && max_new=${#new_ver}

    raw_date="${BUILD_DATES[$pkgname]}"

    # Calculate Age
    diff_hours=9999
    if [[ -n "$raw_date" ]]; then
        build_time=$(date -d "$raw_date" +%s 2>/dev/null || echo 0)
        diff_hours=$(( (now - build_time) / 3600 ))
    fi

    # Determine Priority
    is_crit=0
    [[ ${CRIT_MAP["$pkgname"]} ]] && is_crit=1

    # Update Type
    upd_type=$(get_update_type "$old_ver" "$new_ver")

    # Sort Key: Priority (Crit=0) then Age (Oldest first)
    sort_prio=$(( 1 - is_crit ))
    sort_key=$(printf "%d.%05d" "$sort_prio" "$diff_hours")

    # Write raw data (Tab separated) to temp file
    # Fields: Key, DiffHours, IsCrit, Type, PkgName, OldVer, NewVer, RawDate
    printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$sort_key" "$diff_hours" "$is_crit" "$upd_type" "$pkgname" "$old_ver" "$new_ver" "$raw_date" >> "$OUTPUT_FILE"

done <<< "$updates"

echo -e "\n"

# --- 6. Table Output ---

# Width calculations
w_age=6
w_stat=8
w_type=6
w_name=$(( max_name ))
w_old=$(( max_old ))
w_new=$(( max_new ))

# Separator
total_width=$(( w_age + 1 + w_stat + 1 + w_type + 1 + w_name + 1 + w_old + 3 + w_new + 1 + 15 ))
# Clamp to terminal width
term_cols=$(tput cols)
[[ $total_width -gt $term_cols ]] && total_width=$term_cols

sep_line=$(printf "%${total_width}s" | tr ' ' '-')

# Header
printf "${dim}%s${reset}\n" "$sep_line"
# Note: "OLD" is right aligned, "NEW" is left aligned around the arrow
printf "${bold}${gray}%-${w_age}s %-${w_stat}s %-${w_type}s %-${w_name}s %${w_old}s   %-${w_new}s %s${reset}\n" \
    "AGE" "STATUS" "TYPE" "PACKAGE" "OLD" "NEW" "BUILD DATE"
printf "${dim}%s${reset}\n" "$sep_line"

# Output Rows
sort -n "$OUTPUT_FILE" | while IFS=$'\t' read -r key diff_hours is_crit upd_type pkgname old_ver new_ver raw_date; do

    # 1. Format Age
    if (( diff_hours == 9999 )); then
        age_disp="[?]"
        age_col=$dim
    else
        age_disp="[${diff_hours}h]"
        if (( diff_hours < 12 )); then age_col="${red}${bold}"
        elif (( diff_hours < 48 )); then age_col="${yellow}"
        else age_col="${green}"; fi
    fi
    # Print formatted age variable
    printf -v f_age "%-${w_age}s" "$age_disp"
    out_age="${age_col}${f_age}${reset}"

    # 2. Format Status
    if (( is_crit == 1 )); then
        if (( diff_hours < 24 )); then
            out_stat="${bg_crit} ! CRIT ${reset}"
        else
            out_stat="${bg_core}  CORE  ${reset}"
        fi
    else
        out_stat="$(printf "%-${w_stat}s" " ")"
    fi

    # 3. Format Type
    type_col=$(get_type_color "$upd_type")
    printf -v f_type "%-${w_type}s" "$upd_type"
    out_type="${type_col}${f_type}${reset}"

    # 4. Format Date
    if [[ -n "$raw_date" ]]; then
        f_date=$(LC_TIME=C date -d "$raw_date" "+%d %b %H:%M" 2>/dev/null)
        out_date="${dim}${f_date}${reset}"
    else
        out_date=""
    fi

    # 5. Print Line
    # Structure: AGE | STAT | TYPE | NAME | OLD_VER -> NEW_VER | DATE
    # Colors are applied OUTSIDE the width specifiers for proper alignment
    printf "%b %b %b ${bold}${white}%-${w_name}s${reset} ${gray}%${w_old}s${reset} ${blue}→${reset} ${white}%-${w_new}s${reset} %b\n" \
        "$out_age" \
        "$out_stat" \
        "$out_type" \
        "$pkgname" \
        "$old_ver" \
        "$new_ver" \
        "$out_date"

done

printf "${dim}%s${reset}\n" "$sep_line"

# --- 7. Update Request ---

# Checking commands
if command -v eos-update &> /dev/null; then
    CORE_CMD="eos-update"
else
    CORE_CMD="sudo pacman -Syu"
fi

EXTRA_CMD=""
if command -v topgrade &> /dev/null; then
    EXTRA_CMD="topgrade"
fi

# Forming a query string for the user
if [[ -n "$EXTRA_CMD" ]]; then
    PROMPT_CMD="${CORE_CMD} && ${EXTRA_CMD}"
else
    PROMPT_CMD="${CORE_CMD}"
fi

echo -ne "\n  ${bold}${white}Apply updates?${reset} ${dim}(${PROMPT_CMD})${reset} [Y/n]: "
read -r answer

if [[ "$answer" =~ ^[Yy]$ || -z "$answer" ]]; then
    echo -e "\n"

    # 1. Running a major system update (eos-update)
    $CORE_CMD

    # Saving the return code
    if [[ $? -eq 0 ]]; then
        # 2. Launching Topgrade (if installed)
        if [[ -n "$EXTRA_CMD" ]]; then
            echo -e "\n${blue}${bold}  󰚰  System update complete. Running Topgrade for extras...${reset}\n"
            $EXTRA_CMD
        fi
    else
        echo -e "\n${red}  ✘ Core update failed or cancelled. Skipping Topgrade.${reset}\n"
    fi
else
    echo -e "  ${yellow}Operation cancelled.${reset}\n"
fi
