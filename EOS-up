#!/bin/bash

# --- 1. Color Palette ---
reset='\033[0m'
bold='\033[1m'
dim='\033[2m'
red='\033[38;5;196m'
green='\033[38;5;71m'
yellow='\033[38;5;214m'
blue='\033[38;5;75m'
magenta='\033[38;5;176m'
cyan='\033[38;5;79m'
white='\033[38;5;255m'
gray='\033[38;5;244m'

# Backgrounds for statuses
bg_crit='\033[48;5;160;38;5;255;1m' # Red background
bg_core='\033[48;5;237;38;5;214;1m' # Dark gray background

# --- 2. Critical Package Configuration ---
CRITICAL_PKGS=(
    # --- Kernels & Microcode (AMD CPU) ---
    "linux" "linux-headers"
    "linux-lts" "linux-lts-headers"
    "linux-zen" "linux-zen-headers"
    "linux-hardened" "linux-hardened-headers"
    "linux-firmware" "amd-ucode"

    # --- NVIDIA Drivers (Discrete GPU) ---
    "nvidia" "nvidia-lts" "nvidia-dkms"
    "nvidia-open" "nvidia-open-lts" "nvidia-open-dkms"
    "nvidia-utils" "nvidia-settings" "lib32-nvidia-utils"
    "opencl-nvidia" "lib32-opencl-nvidia"

    # --- Systemd & Init ---
    "systemd" "systemd-libs" "systemd-sysvcompat"
    "systemd-resolvconf"
    "lib32-systemd"

    # --- Core System & Base ---
    "base" "base-devel" "filesystem"
    "glibc" "lib32-glibc" "dbus"
    "gcc-libs" "lib32-gcc-libs" "util-linux"
    "libutil-linux" "openssl" "coreutils" "icu"
    "bash" "zsh" "sudo" "polkit" "shadow"
    "cryptsetup" "device-mapper" "zstd"

    # --- Package Management ---
    "pacman" "pacman-contrib" "pacman-mirrorlist"
    "archlinux-keyring" "endeavouros-keyring"
    "yay" "paru"

    # --- EndeavourOS Specific ---
    "eos-update" "eos-hooks" "endeavouros-theming"
    "welcome" "eos-apps-info" "eos-rankmirrors"
    "eos-sddm-theme"

    # --- Bootloaders ---
    "grub" "efibootmgr" "os-prober" "dracut"

    # --- Graphics Stack (AMD iGPU + Core) ---
    "mesa" "lib32-mesa" "vulkan-icd-loader" "lib32-vulkan-icd-loader"
    "xorg-server" "xorg-xwayland" "wayland" "wayland-protocols"

    # AMD Drivers (iGPU)
    "xf86-video-amdgpu"
    "vulkan-radeon" "lib32-vulkan-radeon"

    # Hardware Video Acceleration (AMD)
    "libva-mesa-driver" "lib32-libva-mesa-driver" "mesa-vdpau"

    # --- KDE Plasma (Desktop Environment) ---
    "plasma-desktop" "plasma-workspace" "kwin"
    "systemsettings" "sddm" "plasma-wayland-session"
    "kde-cli-tools" "powerdevil"

    # Frameworks & Libraries (Qt/Wayland/Nvidia compat)
    "qt6-base" "qt5-base" "kwayland" "egl-wayland"

    # Hybrid Graphics Switcher
    "switcheroo-control" "envycontrol" "optimus-manager"

    # Core Apps
    "dolphin" "konsole"

    # --- Audio & Networking ---
    "pipewire" "pipewire-audio" "wireplumber" "pipewire-pulse" "lib32-pipewire"
    "networkmanager" "iwd" "bluez" "bluez-utils"
)

declare -A CRIT_MAP
for pkg in "${CRITICAL_PKGS[@]}"; do CRIT_MAP["$pkg"]=1; done

# --- 3. Temporary Files ---
OUTPUT_FILE=$(mktemp)
# Using mktemp -d safely
if ! CHECK_DB=$(mktemp -d /tmp/checkupdates-db.XXXXXX); then
    echo -e "${red}Error: Could not create temp db directory.${reset}"
    exit 1
fi

# Safe cleaning
cleanup() {
    [[ -n "$CHECK_DB" && -d "$CHECK_DB" ]] && sudo rm -rf "$CHECK_DB"
    [[ -f "$OUTPUT_FILE" ]] && rm -f "$OUTPUT_FILE"
}
trap cleanup EXIT

# --- 4. Helper Functions ---
log_step() {
    echo -e "${dim}[$(date +%T)] $1${reset}"
}

get_update_type() {
    local old=$1 new=$2

    # 1. Remove Epoch
    local v_old=${old#*:}
    local v_new=${new#*:}

    # Check Epoch change
    if [[ "$old" == *":"* || "$new" == *":"* ]]; then
        local e_old=${old%%:*}
        local e_new=${new%%:*}
        [[ "$e_old" != "$e_new" ]] && { echo "EPOCH"; return; }
    fi

    # 2. Normalize and convert to integer arrays
    local nums_old=($(echo "$v_old" | sed 's/[^0-9]/ /g'))
    local nums_new=($(echo "$v_new" | sed 's/[^0-9]/ /g'))

    # 3. Iterative comparison
    local len=${#nums_new[@]}
    for (( i=0; i<len; i++ )); do
        local n_old=${nums_old[$i]}
        local n_new=${nums_new[$i]}

        # If old version had fewer segments, treat as minor/patch
        [[ -z "$n_old" ]] && { echo "MINOR"; return; }

        if (( 10#$n_old != 10#$n_new )); then

            if (( 10#$n_new >= 2020 && 10#$n_new <= 2100 )); then
                echo "CALVER"
                return
            fi

            if (( i == 0 )); then
                echo "MAJOR"
            elif (( i == 1 )); then
                echo "MINOR"
            else
                echo "Patch"
            fi
            return
        fi
    done

    echo "Patch"
}

get_type_color() {
    case $1 in
        "MAJOR") echo "$red$bold" ;;
        "CALVER") echo "$blue$bold" ;;
        "MINOR") echo "$cyan" ;;
        "EPOCH") echo "$magenta" ;;
        *) echo "$gray" ;;
    esac
}

check_arch_news() {
    log_step "Starting Arch News check (curl)..."
    echo -ne "${gray}  Checking Arch News... ${reset}"

    # Use compressed transfer and simpler grep logic to find the first ITEM pubDate
    if raw_rss=$(curl -sf --compressed --connect-timeout 2 --max-time 3 https://archlinux.org/feeds/news/); then
        # Extract the first pubDate that appears inside an <item> block
        # (The first pubDate in the file is usually the Channel Build Date, which updates constantly)
        raw_date=$(echo "$raw_rss" | awk -F'<pubDate>' '/<item>/ {p=1} p && $2 {print $2; exit}' | awk -F'</pubDate>' '{print $1}')

        if [[ -n "$raw_date" ]]; then
            # Force the use of the C locale to correctly parse dates from RSS
            news_time=$(LC_TIME=C date -d "$raw_date" +%s 2>/dev/null)

            if [[ -n "$news_time" ]]; then
                now_time=$(date +%s)
                diff_hours=$(( (now_time - news_time) / 3600 ))

                if (( diff_hours < 48 )); then
                    echo -e "\r\033[2K${red}${bold}  ⚠ WARNING: Fresh Arch News detected ($diff_hours h ago)!${reset}"
                    echo -e "  ${red}  Check https://archlinux.org/ before updating.${reset}\n"
                    return
                else
                    echo -e "\r\033[2K${green}  ✔ No fresh Arch News (last: ${diff_hours}h ago).${reset}\n"
                    return
                fi
            fi
        fi
    fi

    # Fallback message
    echo -e "\r\033[2K${dim}  ? Could not check Arch News (Connection or parsing error).${reset}\n"
}

# --- 5. Main Logic ---

# 0. Refresh sudo credentials upfront to prevent password prompt from breaking the UI later
log_step "Requesting Sudo access..."
if ! sudo -v; then
    echo -e "${red}Error: Sudo authentication failed.${reset}"
    exit 1
fi

echo -e "\n${blue}${bold}  󰚰  Checking for updates...${reset}"

# 1. Check Arch News
check_arch_news

# 2. Symlink the local database
log_step "Symlinking local DB..."
ln -s /var/lib/pacman/local "$CHECK_DB/local" > /dev/null 2>&1

# 3. Fix Permissions
sudo chown -R root:root "$CHECK_DB"
sudo chmod 755 "$CHECK_DB"

# 4. Synchronize the TEMPORARY database
log_step "Syncing temporary database (pacman -Sy)..."
if ! sudo pacman -Sy --dbpath "$CHECK_DB" --logfile /dev/null; then
    echo -e "${red}Error: Could not sync databases.${reset}"
    exit 1
fi

# 5. Get the list of updates
log_step "Calculating update list (pacman -Qu)..."
updates=$(LC_ALL=C pacman -Qu --dbpath "$CHECK_DB" --color never)

if [[ -z "$updates" ]]; then
    echo -e "${green}  ✔ System is fully up to date.${reset}\n"
    exit 0
fi

pkg_count=$(echo "$updates" | wc -l)
log_step "Found $pkg_count updates. Starting detailed analysis..."
echo -e "${blue}${bold}  󰑮  Analyzing updates: ${white}$pkg_count packages${reset}"

# --- Optimization: Batch fetch extended info ---
all_pkgs=$(echo "$updates" | awk '{print $1}')

# 1. New Package Data (Repo | BuildDate | Size | Description)
log_step "Fetching remote metadata (pacman -Si)..."
declare -A NEW_DATA
# Using the ~|~ separator. Added removal of '~' in description to prevent collisions
while IFS='' read -r line; do
    name=${line%%~|~*}
    rest=${line#*~|~}
    NEW_DATA["$name"]="$rest"
done < <(LC_ALL=C pacman -Si --dbpath "$CHECK_DB" --color never $all_pkgs 2>/dev/null | awk -F': ' '
    /^Name/ {n=$2}
    /^Repository/ {r=$2}
    /^Build Date/ {b=$2}
    /^Download Size/ {s=$2}
    /^Description/ {
        d=$2
        # Description cleanup: replacing |, tab, and ~ with spaces to preserve structure
        gsub(/[|\t~]/, " ", d)
    }
    /^$/ {
        if (n) {
            print n "~|~" r "|" b "|" s "|" d
            n=""
        }
    }
    END {
        if (n) print n "~|~" r "|" b "|" s "|" d
    }
')

# 2. Old Package Data (BuildDate | InstallReason)
log_step "Fetching local metadata (pacman -Qi)..."
declare -A OLD_DATA
while IFS='|' read -r name bdate reason; do
    [[ -z "${OLD_DATA[$name]}" ]] && OLD_DATA["$name"]="$bdate|$reason"
done < <(LC_ALL=C pacman -Qi $all_pkgs 2>/dev/null | awk -F': ' '
    /^Name/ {n=$2}
    /^Build Date/ {b=$2}
    /^Install Reason/ {r=$2}
    /^$/ {if (n) print n "|" b "|" r; n=""}
')

# Calculate Total Download Size (KiB/MiB/GiB -> MiB)
total_download_size=$(LC_ALL=C pacman -Si --dbpath "$CHECK_DB" $all_pkgs 2>/dev/null | awk '
    /^Download Size/ {
        val=$4
        unit=$5
        if (unit == "KiB") val /= 1024
        else if (unit == "GiB") val *= 1024
        sum += val
    }
    END {
        if (sum > 1024) printf "%.2f GiB", sum/1024
        else printf "%.2f MiB", sum
    }
')

log_step "Processing data and calculating diffs..."

now=$(date +%s)
current_idx=0

# Track Max Lengths
max_name=7
max_old=3
max_new=3
max_repo=4
max_size=4

while read -r line; do
    ((current_idx++))
    percent=$(( current_idx * 100 / pkg_count ))

    # Update UI only every 5% or on last item to speed up loop
    if (( percent % 5 == 0 || current_idx == pkg_count )); then
        filled=$(( percent / 5 ))
        empty=$(( 20 - filled ))
        printf "\r\033[2K  ${gray}Analysis: ${blue}["
        printf "%${filled}s" | tr ' ' '='
        printf ">"
        printf "%${empty}s" | tr ' ' '-'
        printf "] ${percent}%%${reset}"
    fi

    pkgname=$(echo "$line" | awk '{print $1}')
    old_ver=$(echo "$line" | awk '{print $2}')
    new_ver=$(echo "$line" | awk '{print $4}')

    # Retrieve Data
    IFS='|' read -r repo date_new size desc <<< "${NEW_DATA[$pkgname]}"
    IFS='|' read -r date_old reason <<< "${OLD_DATA[$pkgname]}"

    # Determine "Explicit" vs "Dependency"
    is_explicit=0
    [[ "$reason" == *"Explicitly"* ]] && is_explicit=1

    # Update lengths
    (( ${#pkgname} > max_name )) && max_name=${#pkgname}
    (( ${#old_ver} > max_old )) && max_old=${#old_ver}
    (( ${#new_ver} > max_new )) && max_new=${#new_ver}
    (( ${#repo} > max_repo )) && max_repo=${#repo}
    (( ${#size} > max_size )) && max_size=${#size}

    # Calculate Age
    diff_hours=9999
    if [[ -n "$date_new" ]]; then
        build_time=$(date -d "$date_new" +%s 2>/dev/null || echo 0)
        diff_hours=$(( (now - build_time) / 3600 ))
    fi

    # Determine Priority
    is_crit=0
    [[ ${CRIT_MAP["$pkgname"]} ]] && is_crit=1

    upd_type=$(get_update_type "$old_ver" "$new_ver")

    # Sort Key
    sort_prio=$(( 1 - is_crit ))
    sort_key=$(printf "%d.%05d" "$sort_prio" "$diff_hours")

    # Write to Temp
    printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$sort_key" "$diff_hours" "$is_crit" "$upd_type" "$pkgname" "$old_ver" "$new_ver" \
        "$repo" "$size" "$is_explicit" "$date_old" "$date_new" "$desc" >> "$OUTPUT_FILE"

done <<< "$updates"

echo -e "\n"

# --- 6. Table Output ---

w_age=6
w_stat=8
w_repo=$(( max_repo ))
w_type=6
w_name=$(( max_name ))
w_old=$(( max_old ))
w_new=$(( max_new ))
w_size=$(( max_size ))
w_date=12

# Calculate remaining width for Description
term_cols=$(tput cols)
# The sum of all fixed margins and paddings
used_width=$(( w_age + 1 + w_stat + 1 + w_repo + 1 + w_type + 1 + w_name + 1 + w_old + 3 + w_new + 1 + w_size + 1 + w_date + 1 ))
w_desc=$(( term_cols - used_width - 1 ))

# Protection against negative width on narrow screens
if (( w_desc < 5 )); then
    w_desc=0
fi

sep_line=$(printf "%${term_cols}s" | tr ' ' '-')

# Header
printf "${dim}%s${reset}\n" "$sep_line"

# Function for centering text
fmt_center() {
    local str="$1"
    local width="$2"
    local len=${#str}
    if (( len >= width )); then
        printf "%s" "$str"
    else
        local l_pad=$(( (width - len) / 2 ))
        local r_pad=$(( width - len - l_pad ))
        printf "%*s%s%*s" $l_pad "" "$str" $r_pad ""
    fi
}

# Generating centered headings
h_age=$(fmt_center "AGE" "$w_age")
h_stat=$(fmt_center "STATUS" "$w_stat")
h_repo=$(fmt_center "REPO" "$w_repo")
h_type=$(fmt_center "TYPE" "$w_type")
h_name=$(fmt_center "PACKAGE" "$w_name")
h_old=$(fmt_center "OLD" "$w_old")
h_new=$(fmt_center "NEW" "$w_new")
h_size=$(fmt_center "SIZE" "$w_size")
h_date=$(fmt_center "NEW DATE" "$w_date")

# Description title (if there is space)
h_desc="DESCRIPTION"
(( w_desc == 0 )) && h_desc=""

# Printing Headlines
# There are spaces between %s that correspond to the indentations in the data lines.
printf "${bold}${gray}%s %s %s %s %s %s   %s %s %s %s${reset}\n" \
    "$h_age" "$h_stat" "$h_repo" "$h_type" "$h_name" "$h_old" "$h_new" "$h_size" "$h_date" "$h_desc"

printf "${dim}%s${reset}\n" "$sep_line"

# Output Rows
sort -n "$OUTPUT_FILE" | while IFS=$'\t' read -r key diff_hours is_crit upd_type pkgname old_ver new_ver repo size is_explicit date_old date_new desc; do

    # 1. Age
    if (( diff_hours == 9999 )); then age_disp="[?]"; age_col=$dim
    else
        age_disp="[${diff_hours}h]"
        if (( diff_hours < 12 )); then age_col="${red}${bold}"
        elif (( diff_hours < 48 )); then age_col="${yellow}"
        else age_col="${green}"; fi
    fi
    printf -v f_age "%-${w_age}s" "$age_disp"
    out_age="${age_col}${f_age}${reset}"

    # 2. Status
    if (( is_crit == 1 )); then
        if (( diff_hours < 24 )); then out_stat="${bg_crit} ! CRIT ${reset}"
        else out_stat="${bg_core}  CORE  ${reset}"; fi
    else out_stat="$(printf "%-${w_stat}s" " ")"; fi

    # 3. Repo (Dimmed) - Pad CONTENT, then color
    printf -v f_repo "%-${w_repo}s" "$repo"
    out_repo="${dim}${f_repo}${reset}"

    # 4. Type
    type_col=$(get_type_color "$upd_type")
    printf -v f_type "%-${w_type}s" "$upd_type"
    out_type="${type_col}${f_type}${reset}"

    # 5. Name (Highlight if Explicit)
    if (( is_explicit == 1 )); then
        name_col="${white}${bold}"
    else
        name_col="${gray}"
    fi
    printf -v f_name "%-${w_name}s" "$pkgname"
    out_name="${name_col}${f_name}${reset}"

    # 6. Dates (Fixed Width Alignment)
    if [[ -n "$date_new" ]]; then
        f_date_raw=$(LC_TIME=C date -d "$date_new" "+%d %b %H:%M" 2>/dev/null)
    else
        f_date_raw=""
    fi
    # Align the date line before adding colors
    printf -v f_date_padded "%-${w_date}s" "$f_date_raw"
    out_date_new="${dim}${f_date_padded}${reset}"

    # 7. Size
    printf -v f_size "%-${w_size}s" "$size"
    out_size="${white}${f_size}${reset}"

    # 8. Description (Truncated)
    if (( w_desc > 0 )); then
        if (( ${#desc} > w_desc )); then
            out_desc="${dim}${desc:0:$((w_desc-1))}…${reset}"
        else
            out_desc="${dim}${desc}${reset}"
        fi
    else
        out_desc=""
    fi

    # Print Line
    # Using %b for blocks containing color codes
    printf "%b %b %b %b %b ${gray}%${w_old}s${reset} ${blue}→${reset} ${white}%-${w_new}s${reset} %b %b %b\n" \
        "$out_age" "$out_stat" "$out_repo" "$out_type" "$out_name" \
        "$old_ver" "$new_ver" "$out_size" "$out_date_new" "$out_desc"

done

printf "${dim}%s${reset}\n" "$sep_line"
echo -e "  ${gray}Total Download Size: ${white}${bold}${total_download_size}${reset}"

# --- 7. Update Request ---

# Check for packages that require a reboot
if awk -F'\t' '$5 ~ /^(linux.*|nvidia.*|systemd.*|.*-ucode|cryptsetup|glibc|linux-firmware|mesa|wayland|xorg-server|dbus.*|qt[56]-base|plasma-.*|kwin|egl-wayland)$/' "$OUTPUT_FILE" | grep -q .; then
    echo -e "  ${red}${bold}⚠  Kernel/Core/DE update detected. Reboot will be required!${reset}"
fi

# Checking commands
if command -v eos-update &> /dev/null; then
    CORE_CMD="eos-update"
else
    CORE_CMD="sudo pacman -Syu"
fi

EXTRA_CMD=""
if command -v topgrade &> /dev/null; then
    EXTRA_CMD="topgrade"
fi

# Forming a query string for the user (Restored executable command string)
if [[ -n "$EXTRA_CMD" ]]; then
    PROMPT_CMD="${CORE_CMD} && ${EXTRA_CMD}"
else
    PROMPT_CMD="${CORE_CMD}"
fi

sudo -v

echo -ne "\n  ${bold}${white}Apply updates?${reset} ${dim}(${PROMPT_CMD})${reset} [Y/n]: "

read -r answer

if [[ "$answer" =~ ^[Yy]$ || -z "$answer" ]]; then
    echo -e "\n"

    # 1. Running a major system update
    $CORE_CMD
    # Saving the return code
    core_exit=$?

    # Checking if there are any updates left in the system
    # This is the Source of Truth, independent of exit codes
    pending_updates=$(LC_ALL=C pacman -Qu 2>/dev/null)

    # Topgrade Launch Decision Logic
    run_extra=false

    # SCENARIO A: The system is clean (Updates successfully applied)
    if [[ -z "$pending_updates" ]]; then
        if [[ $core_exit -eq 0 ]]; then
            echo -e "\n${green}✔ Core updates applied successfully.${reset}"
            run_extra=true
        else
            # Exit code was non-zero, but updates are gone (weird but success)
            echo -e "\n${green}✔ No core updates pending.${reset}"
            run_extra=true
        fi

    # SCENARIO B: Updates are stuck (Cancelled, Failed, or Partial)
    else
        echo -e "\n${yellow}⚠  Core updates were NOT fully applied (Cancelled or Failed).${reset}"

        # If Topgrade is installed, ask whether to launch it manually
        if [[ -n "$EXTRA_CMD" ]]; then
            echo -ne "  ${white}Run ${EXTRA_CMD} anyway? (Flatpaks/AUR etc) [y/N]: ${reset}"
            read -r force_extra
            if [[ "$force_extra" =~ ^[Yy]$ ]]; then
                run_extra=true
            else
                echo -e "  ${dim}Skipping extra updates.${reset}\n"
            fi
        fi
    fi

    # 2. Launching Topgrade
    if [[ "$run_extra" == true && -n "$EXTRA_CMD" ]]; then
        echo -e "\n${blue}${bold}  󰚰  Running Topgrade...${reset}\n"
        $EXTRA_CMD
    elif [[ -n "$pending_updates" ]]; then
        # Restored feedback for partial/cancelled state
        echo -e "\n${red}  ✘ System partially updated or update cancelled.${reset}\n"
    fi

else
    echo -e "  ${yellow}Operation cancelled.${reset}\n"
fi
